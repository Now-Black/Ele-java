## 开发方案

### 1. 客户每日收益计算优化

#### 1.1 分表设计方案

**实施步骤**：

1. **分表规则设计**

   ```sql
   -- 根据客户号后两位进行hash分区
   table_index = client_no % 16
   -- 生成表名：tbclientdlyincome0 ~ tbclientdlyincome15
   ```

2. **历史数据迁移**

   ```sql
   -- 创建16张分表
   CREATE TABLE tbclientdlyincome0 LIKE tbclientdlyincome;
   -- ... 创建 tbclientdlyincome1 ~ tbclientdlyincome15
   
   -- 数据迁移脚本
   INSERT INTO tbclientdlyincome0 
   SELECT * FROM tbclientdlyincome WHERE MOD(client_no, 16) = 0;
   ```

3. **临时表创建**

   ```sql
   -- 为每个分表创建对应的临时表
   CREATE TABLE tbclientdlyincometmp0 ~ tbclientdlyincometmp15
   ```

#### 1.2 多线程并发处理实现

**核心代码实现思路**：

```java
// 1. 初始化线程池
PubRestLessThreadExcutor executor = new PubRestLessThreadExcutor(16, 16, "DailyIncome");
CountDownLatch latch = new CountDownLatch(16);

// 2. 提交16个并发任务
for (int i = 0; i < 16; i++) {
    final int tableIndex = i;
    executor.submit(() -> {
        try {
            // 处理单个分表
            processSingleTable(tableIndex);
        } finally {
            latch.countDown();
        }
    });
}

// 3. 等待所有任务完成
latch.await();
```

**单表处理流程**：

1. **第一步：临时表数据准备（regCUSDLYIncomePre）**

   ```sql
   -- 清空临时表
   TRUNCATE TABLE tbclientdlyincometmp{i};
   
   -- 联合查询插入临时表
   INSERT INTO tbclientdlyincometmp{i}
   SELECT 
       a.client_no,
       a.asset_acc,
       a.ta_client,
       p.prd_code,
       p.real_prd_code,
       -- 申购金额统计
       SUM(CASE WHEN b.busin_code IN ('50','02') THEN b.cfm_amt ELSE 0 END) AS allot_amt,
       -- 赎回金额统计
       SUM(CASE WHEN b.busin_code IN ('03','51') THEN b.cfm_amt ELSE 0 END) AS redeem_amt,
       -- 分红收益计算
       AVG(CASE 
           WHEN d.div_mode='1' THEN d.real_amt 
           WHEN d.div_mode='0' THEN d.reinvest_amt 
           ELSE 0 
       END) AS div_income
   FROM tbshare{i} a
   LEFT JOIN tbtatranscfm00 b ON a.client_no = b.client_no AND a.prd_code = b.prd_code
   LEFT JOIN tbtadivdetail00 d ON a.client_no = d.client_no AND a.prd_code = d.prd_code
   INNER JOIN tbproduct_asy p ON a.prd_code = p.prd_code
   WHERE b.cfm_date = ? AND p.interest_way = 'JZL'
   GROUP BY a.client_no, a.asset_acc, a.ta_client, p.prd_code, p.real_prd_code;
   ```

2. **第二步：正式表数据处理（regCUSDLYIncomeCal）**

   ```sql
   -- 删除当天和前一天的数据（处理强增强减）
   DELETE FROM tbclientdlyincome{i} 
   WHERE reg_date >= DATE_SUB(?, INTERVAL 1 DAY);
   
   -- 插入汇总数据
   INSERT INTO tbclientdlyincome{i}
   SELECT * FROM (
       -- 已有数据
       SELECT * FROM tbclientdlyincome{i} WHERE reg_date < ?
       UNION ALL
       -- 新计算数据
       SELECT * FROM tbclientdlyincometmp{i}
   ) t
   GROUP BY client_no, prd_code, reg_date;
   
   -- 更新特殊业务（强增强减）
   UPDATE tbclientdlyincome{i} a
   INNER JOIN tbtatranscfm00 b ON a.client_no = b.client_no
   SET a.force_add_amt = b.cfm_amt
   WHERE b.busin_code IN ('70','71','210') AND b.cfm_date = ?;
   ```

#### 1.3 批量数据汇总

**汇总到主表流程**：

```java
// 分批处理，每批5000条
int batchSize = 5000;
List<String> insertSqls = new ArrayList<>();

for (int i = 0; i < 16; i++) {
    String sql = String.format(
        "INSERT INTO tbclientdlyincome " +
        "SELECT * FROM tbclientdlyincome%d WHERE reg_date = ?", i
    );
    insertSqls.add(sql);
}

// 批量执行
executeBatch(insertSqls, batchSize);
```

## 业务逻辑详解

### 1. 客户每日收益计算

#### 1.1 业务目的

客户每日收益计算是TA系统的核心功能，主要计算每个客户持有的理财产品在当日产生的收益，包括：

- **净值增长收益**：由于产品净值变动带来的浮动收益
- **分红收益**：产品分红产生的收益（现金分红或红利再投资）
- **交易收益**：申购、赎回等交易产生的收益差

#### 1.2 数据来源和计算逻辑

**核心数据表**：

1. **tbshare（份额表）**（本身就被分为了16张表）
   - `client_no`：客户编号
   - `prd_code`：产品代码
   - `tot_vol`：持有总份额
   - `last_date`：最后交易日期
   - `asset_acc`：资产账户

2. **tbproduct_asy（产品信息表）**
   - `prd_code`：产品代码
   - `real_prd_code`：实际产品代码（用于净值类产品）
   - `interest_way`：计息方式（'JZL'表示净值类）
   - `nav_value`：产品净值

3. **tbtatranscfm00（交易确认表）**
   - `client_no`：客户编号
   - `prd_code`：产品代码
   - `busin_code`：业务代码
   - `cfm_amt`：确认金额
   - `cfm_date`：确认日期

4. **tbtadivdetail00（分红明细表）**
   - `client_no`：客户编号
   - `prd_code`：产品代码
   - `div_mode`：分红方式（'1'现金分红，'0'红利再投资）
   - `real_amt`：实际分红金额
   - `reinvest_amt`：再投资金额

**计算公式**：

```sql
-- 1. 申购/认购金额统计
allot_amt = SUM(CASE WHEN busin_code IN ('50','02') THEN cfm_amt ELSE 0 END)

-- 2. 赎回金额统计
redeem_amt = SUM(CASE WHEN busin_code IN ('03','51') THEN cfm_amt ELSE 0 END)

-- 3. 分红收益计算
div_income = AVG(CASE 
    WHEN div_mode='1' THEN real_amt      -- 现金分红
    WHEN div_mode='0' THEN reinvest_amt  -- 红利再投资
    ELSE 0 
END)

-- 4. 特殊赎回收益（清仓赎回）
redeem_income = SUM(CASE 
    WHEN (tot_vol = 0 AND last_date <= ? AND busin_code='03') OR busin_code='51'
    THEN cfm_amt 
    ELSE 0 
END)

-- 5. 强增强减处理（特殊调整）
force_add_amt = SUM(CASE WHEN busin_code IN ('70','71','210') THEN cfm_amt ELSE 0 END)
```

#### 1.3 处理流程

1. **临时表计算**：先将当日交易数据和分红数据汇总到临时表
2. **历史数据合并**：与前一日的收益数据合并
3. **特殊业务处理**：处理强增强减等特殊调整
4. **数据汇总**：按产品、销售商等维度进行汇总